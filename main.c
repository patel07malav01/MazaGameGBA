#include "main.h"

#include <stdio.h>
#include <stdlib.h>

#include "gba.h"
/* TODO: */

#include "first_image.h" 
#include "win_image.h"
#include "lose_image.h"
#include "target.h" 

// Include any header files for title screen or exit
// screen images generated by nin10kit. Example for the provided garbage
// image:
// #include "images/garbage.h"

/* TODO: */
// Add any additional states you need for your app. You are not requried to use
// these specific provided states.
enum gba_state {
  START,
  PLAY,
  WIN,
  LOSE,
};


int main(void) {
  /* TODO: */
  // Manipulate REG_DISPCNT here to set Mode 3. //

  REG_DISPCNT = MODE3 | BG2_ENABLE; 

  // Save current and previous state of button input.
  u32 previousButtons = BUTTONS;
  u32 currentButtons = BUTTONS;

  // Load initial application state
  enum gba_state state = START;

  struct ball bs; 
  bs.curr_col = 0; 
  bs.curr_row = 0; 
  bs.height = 5; 
  bs.width = 5; 
  bs.color = RED | BLUE;

  int rand[240] = {0}; 
  char str[500];

  for(int i = 29; i < WIDTH; i+=30){
    rand[i] = randint(0, HEIGHT);
  }

  while (1) {
    currentButtons = BUTTONS; // Load the current state of the buttons

    waitForVBlank(); 

    if(KEY_DOWN(BUTTON_SELECT, currentButtons) && !KEY_DOWN(BUTTON_SELECT, previousButtons)) {
      state = START;  
      vBlankCounter = 0; 
    }   

    /* TODO: */
    // Manipulate the state machine below as needed //
    // NOTE: Call waitForVBlank() before you draw

    switch (state) {
      case START:

        drawFullScreenImageDMA(first_image); 

        drawCenteredString(150, 100, 4, 1, "Click enter to start the game !!", BLACK); 
        
        if(KEY_DOWN(BUTTON_START, currentButtons) && !KEY_DOWN(BUTTON_START, previousButtons)) {
          state = PLAY; 

          drawRectDMA(0, 0, WIDTH, HEIGHT, BLACK);  
          bs.curr_col = 0; 
          bs.curr_row = 0; 
          bs.height = 5; 
          bs.width = 5; 
          bs.color = RED | BLUE;

          for(int i = 29; i < WIDTH; i+=30){
            drawRectDMA(0, i, 1, rand[i] - 4, WHITE);
            drawRectDMA(rand[i] + 5, i, 1, HEIGHT - rand[i] - 1, WHITE);
          }
          drawRectDMA(bs.curr_row, bs.curr_col, bs.width, bs.height, bs.color);

          drawImageDMA(90, 212, 25, 25, target);

        }

        break;

      case PLAY:

        vBlankCounter++; 

        sprintf(str, "Time Taken: %lu", (unsigned long) (vBlankCounter / 120));   
        drawRectDMA(150, 0, 85, 10, BLACK); 
        drawString(150, 0, str, YELLOW | WHITE); 

        if(vBlankCounter > 30 * 120){ 
          state = LOSE; 
        }


        if(KEY_DOWN(BUTTON_UP, currentButtons) && !KEY_DOWN(BUTTON_UP, previousButtons)) {
          
          if(bs.curr_row <= 0) { 
            break; 
          }

          if(bs.curr_row == 90 + 25 && bs.curr_col > WIDTH - 30) {
            state = WIN; 
          }

          drawRectDMA(bs.curr_row, bs.curr_col, bs.width, bs.height, BLACK); 
          bs.curr_row-=5;
          drawImageDMA(90, 212, 25, 25, target);
          drawRectDMA(bs.curr_row, bs.curr_col, bs.width, bs.height, bs.color);

          for(int i = 29; i < 240; i+=30) {
            if(bs.curr_col + 4 == i) {
              if(bs.curr_row < rand[i] - 4 || bs.curr_row > rand[i] + 4) {
                state = LOSE; 
                break;
              }
            }
          }

        }

        if(KEY_DOWN(BUTTON_DOWN, currentButtons) && !KEY_DOWN(BUTTON_DOWN, previousButtons)) {

          if(bs.curr_row + 5 >= HEIGHT - 1) { 
            break; 
          }

          if(bs.curr_row + 5 == 90 && bs.curr_col > WIDTH - 30) {
            state = WIN; 
          }

          drawRectDMA(bs.curr_row, bs.curr_col, bs.width, bs.height, BLACK); 
          bs.curr_row+=5;
          drawImageDMA(90, 212, 25, 25, target);
          drawRectDMA(bs.curr_row, bs.curr_col, bs.width, bs.height, bs.color);  

          for(int i = 29; i < 240; i+=30) {
            if(bs.curr_col + 4 == i) {
              if(bs.curr_row < rand[i] - 4 || bs.curr_row > rand[i] + 4) {
                state = LOSE; 
                break;
              }
            }
          }

        }

        if(KEY_DOWN(BUTTON_LEFT, currentButtons) && !KEY_DOWN(BUTTON_LEFT, previousButtons)) {

          if(bs.curr_col <= 0) { 
            break; 
          }

          drawRectDMA(bs.curr_row, bs.curr_col, bs.width, bs.height, BLACK); 
          bs.curr_col-=5;
          drawImageDMA(90, 212, 25, 25, target);
          drawRectDMA(bs.curr_row, bs.curr_col, bs.width, bs.height, bs.color);

          for(int i = 29; i < 240; i+=30) {
            if(bs.curr_col == i + 1) {
              if(bs.curr_row <= rand[i] - 4 || bs.curr_row >= rand[i] + 4){
                state = LOSE; 
                break;
              }
            }
          }

        }

        if(KEY_DOWN(BUTTON_RIGHT, currentButtons) && !KEY_DOWN(BUTTON_RIGHT, previousButtons)) {

          if(bs.curr_col + 10 >= WIDTH - 1 ) { 
            state = LOSE; 
            break; 
          }

          drawRectDMA(bs.curr_row, bs.curr_col, bs.width, bs.height, BLACK); 
          bs.curr_col+=5;
          drawImageDMA(90, 212, 25, 25, target);
          drawRectDMA(bs.curr_row, bs.curr_col, bs.width, bs.height, bs.color);

          if(bs.curr_col == 212 && bs.curr_row + 5 == 90) {
            state = WIN; 
          }

          for(int i = 29; i < 240; i+=30) {
            if(bs.curr_col + 4 == i) {
              if(bs.curr_row < rand[i] - 4 || bs.curr_row > rand[i] + 4) {
                state = LOSE; 
                break;
              }
            }
          }

        }

        break;

      case WIN:
        
        drawFullScreenImageDMA(win_image); 
        drawCenteredString(155, 100, 4, 1, "Congrats!! BACKSPACE=RESTART", BLACK);

        break;

      case LOSE:
        
        drawFullScreenImageDMA(lose_image); 
        drawCenteredString(155, 110, 4, 1, "Sorry! BACKSPACE=RESTART", BLACK); 
       
        break;

    }

    previousButtons = currentButtons; // Store the current state of the buttons
  }

  return 0;
}
